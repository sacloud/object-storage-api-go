// Copyright 2022-2026 The sacloud/object-storage-api-go authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by ogen, DO NOT EDIT.

package v1

import (
	std "encoding/json"
	"fmt"
	"testing"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"
	"github.com/stretchr/testify/require"
)

func TestAccessKeyID_EncodeDecode(t *testing.T) {
	var typ AccessKeyID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessKeyID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccount_EncodeDecode(t *testing.T) {
	var typ Account
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Account
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccountData_EncodeDecode(t *testing.T) {
	var typ AccountData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccountData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccountKey_EncodeDecode(t *testing.T) {
	var typ AccountKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccountKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccountKeyData_EncodeDecode(t *testing.T) {
	var typ AccountKeyData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccountKeyData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccountKeys_EncodeDecode(t *testing.T) {
	var typ AccountKeys
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccountKeys
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccountKeysDataItem_EncodeDecode(t *testing.T) {
	var typ AccountKeysDataItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccountKeysDataItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketBillingItem_EncodeDecode(t *testing.T) {
	var typ BucketBillingItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketBillingItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketBillingItemDetail_EncodeDecode(t *testing.T) {
	var typ BucketBillingItemDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketBillingItemDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketControls_EncodeDecode(t *testing.T) {
	var typ BucketControls
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketControls
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketControlsItem_EncodeDecode(t *testing.T) {
	var typ BucketControlsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketControlsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketList_EncodeDecode(t *testing.T) {
	var typ BucketList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketListDataItem_EncodeDecode(t *testing.T) {
	var typ BucketListDataItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketListDataItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketListDataItemPlan_EncodeDecode(t *testing.T) {
	var typ BucketListDataItemPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketListDataItemPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketName_EncodeDecode(t *testing.T) {
	var typ BucketName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketPenalty_EncodeDecode(t *testing.T) {
	var typ BucketPenalty
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketPenalty
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketPenaltyData_EncodeDecode(t *testing.T) {
	var typ BucketPenaltyData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketPenaltyData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketPenaltyDataAmountGibPerBucket_EncodeDecode(t *testing.T) {
	var typ BucketPenaltyDataAmountGibPerBucket
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketPenaltyDataAmountGibPerBucket
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketPenaltyDataNumObjectsPerBucket_EncodeDecode(t *testing.T) {
	var typ BucketPenaltyDataNumObjectsPerBucket
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketPenaltyDataNumObjectsPerBucket
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketQuota_EncodeDecode(t *testing.T) {
	var typ BucketQuota
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketQuota
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketQuotaData_EncodeDecode(t *testing.T) {
	var typ BucketQuotaData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketQuotaData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketUsage_EncodeDecode(t *testing.T) {
	var typ BucketUsage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketUsage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucketUsageData_EncodeDecode(t *testing.T) {
	var typ BucketUsageData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BucketUsageData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCanRead_EncodeDecode(t *testing.T) {
	var typ CanRead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CanRead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCanWrite_EncodeDecode(t *testing.T) {
	var typ CanWrite
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CanWrite
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCode_EncodeDecode(t *testing.T) {
	var typ Code
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Code
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContractSummary_EncodeDecode(t *testing.T) {
	var typ ContractSummary
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContractSummary
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContractSummaryStatus_EncodeDecode(t *testing.T) {
	var typ ContractSummaryStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContractSummaryStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatedAt_EncodeDecode(t *testing.T) {
	var typ CreatedAt
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatedAt
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDisplayName_EncodeDecode(t *testing.T) {
	var typ DisplayName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DisplayName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError400_EncodeDecode(t *testing.T) {
	var typ Error400
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error400
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError400Error_EncodeDecode(t *testing.T) {
	var typ Error400Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error400Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError401_EncodeDecode(t *testing.T) {
	var typ Error401
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error401
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError401Error_EncodeDecode(t *testing.T) {
	var typ Error401Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error401Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError403_EncodeDecode(t *testing.T) {
	var typ Error403
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error403
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError403Error_EncodeDecode(t *testing.T) {
	var typ Error403Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error403Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError404_EncodeDecode(t *testing.T) {
	var typ Error404
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error404
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError404Error_EncodeDecode(t *testing.T) {
	var typ Error404Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error404Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError409_EncodeDecode(t *testing.T) {
	var typ Error409
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error409
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError409Error_EncodeDecode(t *testing.T) {
	var typ Error409Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error409Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorCode_EncodeDecode(t *testing.T) {
	var typ ErrorCode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorCode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorDefault_EncodeDecode(t *testing.T) {
	var typ ErrorDefault
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorDefault
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorDefaultError_EncodeDecode(t *testing.T) {
	var typ ErrorDefaultError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorDefaultError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorMessage_EncodeDecode(t *testing.T) {
	var typ ErrorMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorTraceId_EncodeDecode(t *testing.T) {
	var typ ErrorTraceId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorTraceId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrors_EncodeDecode(t *testing.T) {
	var typ Errors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Errors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorsDomain_EncodeDecode(t *testing.T) {
	var typ ErrorsDomain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorsDomain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorsItem_EncodeDecode(t *testing.T) {
	var typ ErrorsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorsLocation_EncodeDecode(t *testing.T) {
	var typ ErrorsLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorsLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorsLocationType_EncodeDecode(t *testing.T) {
	var typ ErrorsLocationType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorsLocationType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorsMessage_EncodeDecode(t *testing.T) {
	var typ ErrorsMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorsMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorsReason_EncodeDecode(t *testing.T) {
	var typ ErrorsReason
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorsReason
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBucketEncryptionOK_EncodeDecode(t *testing.T) {
	var typ GetBucketEncryptionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBucketEncryptionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBucketMeteringOK_EncodeDecode(t *testing.T) {
	var typ GetBucketMeteringOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBucketMeteringOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBucketPlanOK_EncodeDecode(t *testing.T) {
	var typ GetBucketPlanOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBucketPlanOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPlansOK_EncodeDecode(t *testing.T) {
	var typ GetPlansOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPlansOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerEncryptionConfigReqBody_EncodeDecode(t *testing.T) {
	var typ HandlerEncryptionConfigReqBody
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerEncryptionConfigReqBody
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerEncryptionConfigRes_EncodeDecode(t *testing.T) {
	var typ HandlerEncryptionConfigRes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerEncryptionConfigRes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerGetClusterRes_EncodeDecode(t *testing.T) {
	var typ HandlerGetClusterRes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerGetClusterRes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerGetReplicableTargetsRes_EncodeDecode(t *testing.T) {
	var typ HandlerGetReplicableTargetsRes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerGetReplicableTargetsRes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerGetReplicationRes_EncodeDecode(t *testing.T) {
	var typ HandlerGetReplicationRes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerGetReplicationRes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestHandlerGetReplicationRes_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"data\":{\"config_status\":\"created\",\"created_at\":\"2024-01-01T12:00:00+09:00\",\"dest_bucket\":{\"cluster_id\":\"tky01\",\"name\":\"my-bucket-replica\",\"plan\":{\"service_class_path\":\"\",\"type\":\"\"}},\"source_bucket\":{\"cluster_id\":\"isk01\",\"name\":\"my-bucket\",\"plan\":{\"service_class_path\":\"\",\"type\":\"\"}}}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ HandlerGetReplicationRes

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 HandlerGetReplicationRes
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestHandlerListClustersRes_EncodeDecode(t *testing.T) {
	var typ HandlerListClustersRes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerListClustersRes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerPostReplicationRes_EncodeDecode(t *testing.T) {
	var typ HandlerPostReplicationRes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerPostReplicationRes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestHandlerPostReplicationRes_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"data\":{\"config_status\":\"created\",\"created_at\":\"2024-01-01T12:00:00+09:00\",\"dest_bucket\":{\"cluster_id\":\"tky01\",\"name\":\"my-bucket-replica\",\"plan\":{\"service_class_path\":\"\",\"type\":\"\"}},\"source_bucket\":{\"cluster_id\":\"isk01\",\"name\":\"my-bucket\",\"plan\":{\"service_class_path\":\"\",\"type\":\"\"}}}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ HandlerPostReplicationRes

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 HandlerPostReplicationRes
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestHandlerPutBucketReqBody_EncodeDecode(t *testing.T) {
	var typ HandlerPutBucketReqBody
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerPutBucketReqBody
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerPutBucketReqBodyPlan_EncodeDecode(t *testing.T) {
	var typ HandlerPutBucketReqBodyPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerPutBucketReqBodyPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHandlerPutBucketRes_EncodeDecode(t *testing.T) {
	var typ HandlerPutBucketRes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HandlerPutBucketRes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelBucket_EncodeDecode(t *testing.T) {
	var typ ModelBucket
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelBucket
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestModelBucket_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"cluster_id\":\"isk01\",\"name\":\"my-bucket\",\"plan\":{\"service_class_path\":\"objectstorage/isk01/bucket\",\"type\":\"standard\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ModelBucket

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ModelBucket
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestModelBucketPlan_EncodeDecode(t *testing.T) {
	var typ ModelBucketPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelBucketPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelCluster_EncodeDecode(t *testing.T) {
	var typ ModelCluster
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelCluster
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelClusterPlanFamily_EncodeDecode(t *testing.T) {
	var typ ModelClusterPlanFamily
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelClusterPlanFamily
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestModelClusterPlanFamily_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"standard\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ModelClusterPlanFamily

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ModelClusterPlanFamily
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestModelPlanType_EncodeDecode(t *testing.T) {
	var typ ModelPlanType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelPlanType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestModelPlanType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"archive\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ModelPlanType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ModelPlanType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestModelReplication_EncodeDecode(t *testing.T) {
	var typ ModelReplication
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelReplication
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelReplicationConfigStatus_EncodeDecode(t *testing.T) {
	var typ ModelReplicationConfigStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelReplicationConfigStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelReplicationDestBucket_EncodeDecode(t *testing.T) {
	var typ ModelReplicationDestBucket
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelReplicationDestBucket
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestModelReplicationDestBucket_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"cluster_id\":\"tky01\",\"name\":\"my-bucket-replica\",\"plan\":{\"service_class_path\":\"objectstorage/isk01/bucket\",\"type\":\"standard\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ModelReplicationDestBucket

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ModelReplicationDestBucket
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestModelReplicationDestBucketPlan_EncodeDecode(t *testing.T) {
	var typ ModelReplicationDestBucketPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelReplicationDestBucketPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestModelReplicationSourceBucket_EncodeDecode(t *testing.T) {
	var typ ModelReplicationSourceBucket
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelReplicationSourceBucket
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestModelReplicationSourceBucket_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"cluster_id\":\"isk01\",\"name\":\"my-bucket\",\"plan\":{\"service_class_path\":\"objectstorage/isk01/bucket\",\"type\":\"standard\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ModelReplicationSourceBucket

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ModelReplicationSourceBucket
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestModelReplicationSourceBucketPlan_EncodeDecode(t *testing.T) {
	var typ ModelReplicationSourceBucketPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ModelReplicationSourceBucketPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermission_EncodeDecode(t *testing.T) {
	var typ Permission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Permission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionBucketControlsBody_EncodeDecode(t *testing.T) {
	var typ PermissionBucketControlsBody
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionBucketControlsBody
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionData_EncodeDecode(t *testing.T) {
	var typ PermissionData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionID_EncodeDecode(t *testing.T) {
	var typ PermissionID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionKey_EncodeDecode(t *testing.T) {
	var typ PermissionKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionKeyData_EncodeDecode(t *testing.T) {
	var typ PermissionKeyData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionKeyData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionKeyID_EncodeDecode(t *testing.T) {
	var typ PermissionKeyID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionKeyID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionKeys_EncodeDecode(t *testing.T) {
	var typ PermissionKeys
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionKeys
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionKeysDataItem_EncodeDecode(t *testing.T) {
	var typ PermissionKeysDataItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionKeysDataItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionSecret_EncodeDecode(t *testing.T) {
	var typ PermissionSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissions_EncodeDecode(t *testing.T) {
	var typ Permissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Permissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPermissionsDataItem_EncodeDecode(t *testing.T) {
	var typ PermissionsDataItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PermissionsDataItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanChangeReqBody_EncodeDecode(t *testing.T) {
	var typ PlanChangeReqBody
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanChangeReqBody
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanChangeReqBodyNewPlan_EncodeDecode(t *testing.T) {
	var typ PlanChangeReqBodyNewPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanChangeReqBodyNewPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanChangeReqBodyPreviousContract_EncodeDecode(t *testing.T) {
	var typ PlanChangeReqBodyPreviousContract
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanChangeReqBodyPreviousContract
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanChangeResBody_EncodeDecode(t *testing.T) {
	var typ PlanChangeResBody
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanChangeResBody
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanItem_EncodeDecode(t *testing.T) {
	var typ PlanItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanItemFee_EncodeDecode(t *testing.T) {
	var typ PlanItemFee
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanItemFee
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanSummary_EncodeDecode(t *testing.T) {
	var typ PlanSummary
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanSummary
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanWithContract_EncodeDecode(t *testing.T) {
	var typ PlanWithContract
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanWithContract
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostBucketReplicationReq_EncodeDecode(t *testing.T) {
	var typ PostBucketReplicationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostBucketReplicationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutBucketEncryptionOK_EncodeDecode(t *testing.T) {
	var typ PutBucketEncryptionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutBucketEncryptionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPutBucketPlanOK_EncodeDecode(t *testing.T) {
	var typ PutBucketPlanOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PutBucketPlanOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestQuota_EncodeDecode(t *testing.T) {
	var typ Quota
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Quota
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestQuotaData_EncodeDecode(t *testing.T) {
	var typ QuotaData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 QuotaData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResourceID_EncodeDecode(t *testing.T) {
	var typ ResourceID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResourceID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSecretAccessKey_EncodeDecode(t *testing.T) {
	var typ SecretAccessKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SecretAccessKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceClassPath_EncodeDecode(t *testing.T) {
	var typ ServiceClassPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceClassPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStatus_EncodeDecode(t *testing.T) {
	var typ Status
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Status
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStatusData_EncodeDecode(t *testing.T) {
	var typ StatusData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StatusData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStatusDataStatusCode_EncodeDecode(t *testing.T) {
	var typ StatusDataStatusCode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StatusDataStatusCode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
